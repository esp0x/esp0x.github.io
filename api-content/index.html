{"posts":[{"title":"Mysql主从复制原理","content":"原理图如下： 主从复制流程详解： master库发生数据改变时，会将改变写入binglog日志； slave库会在一定时间间隔内对master的binlog进行检测以确定是否发生改变，如果发生改变，则开始一个IO thread请求master二进制事件； 同时，master为每一个过来请求的IO thread开启一个dump线程，用于将二进制事件发送给IO thread，slave的IO thread将此二进制事件写入本地relay log（中继日志）中，并开启SQL thread从中继日志中读取二进制日志，在本地进行重放（replay），从而使得本地数据与master保持一致；最后IO thread和SQL thread进入睡眠状态，等待下次唤醒。 主从复制形式： 主从 主主 一主多从 多主一从 联级复制 主从同步延时分析： master对所有DDL和DML产生的日志都写入binlog，由于是顺序写，所以效率很高；反之，slave的SQL thread进行relay log的重放时，DML和DDL的IO是随机的，不是顺序，所以成本较高，这里会增加一部分延时； 由于SQL thread是单线程的，当master的并发较高时，过多的DML可能会导致slave的SQL thread来不及处理，这里会增加一部分延时； slave中有部分SQL产生了锁等待，这种情况就是slave有一些读请求与重放请求产生了锁冲突导致的，也会增加延时； slave在充当读库角色的时候，如果查询访问压力过大，会消耗部分系统资源，影响同步效率； 大事务执行，即当master有大事务执行时，比如执行了10分钟，binlog写入必须要等待事务处理完毕，那么slave开始进行同步的时候就已经延时10分钟了； 延时解决办法： 业务层实现读写分离，一主多从，主写从读，分散压力； 业务层和数据库层之间加入缓存策略，降低直接对数据库的读压力；频繁写的场景不适合加缓存，会导致缓存命中降低； 升级硬件； MTS问题，即多线程的slave，从5.6版本开始支持，针对不同粒度（库、表、行）设置并行同步； 5.7版本后的并行复制策略 Redo log的两阶段提交 先写redo，再写binlog：假设在redo写完，binlog还没有写完的时候，Mysql进程异常重启，这时仍然能够通过redo log恢复数据，但由于binlog没有这条记录，所以之后备份日志的时候，binlog是缺失这条记录的，以后需要用binlog恢复数据时，就会缺少一条数据的更新； 先写binlog，再写redo log：如果binlog写完后crash，由于redo log还没写，崩溃恢复后这个事务无效，但是binlog有记录，以后用这个binlog恢复数据时，就会多出一条更新记录； 二阶段提交：使用二阶段提交时，会综合redo和binlog的状态进行处理，如果写入binlog之前crash，那么由于redo处于prepare阶段，只需要对当前事务进行回滚即可；如果写入binlog之后crash，那么由于redo处于prepare阶段，只需要对当前事务进行提交即可。 并行复制的思想 同时处于prepare状态的事务，在备库执行是可以并行的； 处于prepare状态的事务，与处于commit状态的事务之间，在备库执行也是可以并行的； binlog_group_commit_sync_delay参数，表示延迟多少微妙后才调用fsync； binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync； ","link":"https://esp0x.github.io/post/mysql-zhu-cong-fu-zhi-yuan-li/"}]}