<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://esp0x.github.io</id>
    <title>Grey</title>
    <updated>2021-06-07T09:29:26.380Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://esp0x.github.io"/>
    <link rel="self" href="https://esp0x.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://esp0x.github.io/images/avatar.png</logo>
    <icon>https://esp0x.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Grey</rights>
    <entry>
        <title type="html"><![CDATA[Playbook中使用copy来传输文件]]></title>
        <id>https://esp0x.github.io/post/playbook-zhong-shi-yong-copy-lai-chuan-shu-wen-jian/</id>
        <link href="https://esp0x.github.io/post/playbook-zhong-shi-yong-copy-lai-chuan-shu-wen-jian/">
        </link>
        <updated>2021-06-07T09:27:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基本配置示例">基本配置示例</h3>
<pre><code class="language-shell">- hosts: all
    vars: 
      wss_url: http://10.77.10.125:8545 
    tasks:
      - name: &quot;推送配置文件&quot;
        template: src=/home/fm/ops/scripts/default.yaml dest=/etc/bee/default.yaml
      - name: &quot;send all scripts&quot;
        copy:
          src: '{{ item.src }}'
          dest: /tmp/
          owner: root
          group: root
          mode: 755
        with_items:
          - { src: '/home/fm/ops/scripts/start05.sh' }
          - { src: '/home/fm/ops/scripts/stop.sh' }
  
 
# 使用{{ item.src }}读取with_items中的数组元素，访问需要拷贝的每一个文件即可。

# 检查语法
ansible-playbook --syntax-check example.yaml
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Playbook中用户的切换问题]]></title>
        <id>https://esp0x.github.io/post/playbook-zhong-yong-hu-de-qie-huan-wen-ti/</id>
        <link href="https://esp0x.github.io/post/playbook-zhong-yong-hu-de-qie-huan-wen-ti/">
        </link>
        <updated>2021-06-07T09:21:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="become配置示例">become配置示例：</h3>
<pre><code class="language-shell">- hosts: www.360.com
  remote_user: zabbix
  become: yes
  become_method: su
  tasks:
   - selinux:
        state: disabled
   - name: disable firewalld
     shell: systemctl stop firewalld &amp;&amp; systemctl disable firewalld
 
# become说明
become:        yes  # 是否允许身份切换
become_method: su   # 切换用户身份的方式，有sudo、su、pbrun等方式，默认为sudo
become_user: root   # 切换指定的用户，默认不写，就是root
</code></pre>
<h3 id="sudo配置解释">sudo配置解释</h3>
<pre><code class="language-shell">hosts                # 指定主机分组，可以取并集，交集等
remote_user          # 用于指定远程主机上的执行任务的用户，最佳实践是该用户具有sudo权限
user                 # 和remote_user相同
sudo                 # 如果设置为yes，执行该任务组的用户在执行任务的时候，获取root权限，也可以命令行使用-b参数
sudo_user            # 如果设置user为A，sudo为yes，sudo_user为B时，则A用户在执行任务时会获得B用户的权限，比较麻烦，不推荐
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Playbook利用tags执行部分task]]></title>
        <id>https://esp0x.github.io/post/playbook-li-yong-tags-zhi-xing-bu-fen-task/</id>
        <link href="https://esp0x.github.io/post/playbook-li-yong-tags-zhi-xing-bu-fen-task/">
        </link>
        <updated>2021-06-07T09:20:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基本使用方法示例配置">基本使用方法，示例配置：</h3>
<pre><code class="language-shell">tasks:
  - yum: name={{ item }} state=installed
    with_items:
       - httpd
    tags:
       - packages
  - name: copy httpd.conf
    template: src=templates/httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf
    tags:
       - configuration
  - name: copy index.html
    template: src=templates/index.html.j2 dest=/var/www/html/index.html
    tags:
       - configuration
  
 
# 执行部分任务
ansible-playbook example.yml --tags &quot;packages&quot;

# 指定不执行packages部分的任务
ansible-playbook example.yml --skip-tags &quot;configuration&quot;
</code></pre>
<h3 id="特殊的tags">特殊的tags</h3>
<pre><code class="language-shell"># always 标签，即使指定执行了某tag的任务，标记为always的任务也会被执行
tasks:
  - debug: msg=&quot;Always print this debug message&quot;
    tags:
      - always
  - yum: name={{ item }} state=installed
    with_items:
       - httpd
    tags:
       - packages
  - template: src=templates/httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf
    tags:
       - configuration

# 这里标记为always的任务也会被执行
ansible-playbook tags_always.yml --tags &quot;packages&quot;

# targged，untagged，all，使用这些标签时，不需要加双引号
tagged，即执行所有被打标签的任务
untagged，即执行所有未被打标签的任务
all，所有任务
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用prometheus监控主机docker容器运行状态]]></title>
        <id>https://esp0x.github.io/post/shi-yong-prometheus-jian-kong-zhu-ji-docker-rong-qi-yun-xing-zhuang-tai/</id>
        <link href="https://esp0x.github.io/post/shi-yong-prometheus-jian-kong-zhu-ji-docker-rong-qi-yun-xing-zhuang-tai/">
        </link>
        <updated>2021-06-07T08:27:03.000Z</updated>
        <content type="html"><![CDATA[<h3 id="部署方式容器化部署">部署方式：容器化部署</h3>
<h4 id="部署流程">部署流程：</h4>
<pre><code class="language-shell"># 运行node-exporter监控主机基本信息，访问9100端口进行验证
docker run -d --name node \
	-p 9100:9100 \
	-v /proc:/host/proc \
	-v /sys:/host/sys \
	-v /:/rootfs \
	--net=host prom/node-exporter \
	--path.procfs /host/proc \
	--path.sysfs /host/sys \
	--collector.filesystem.ignored-mount-points &quot;^/(sys|proc|dev|host|etc)($|/)&quot;

# 运行cAdvisor监控容器运行状态，访问8080端口进行验证
docker run -v /:/rootfs:ro \
	-v /var/run:/var/run/:rw \
	-v /sys:/sys:ro \
	-v /var/lib/docker:/var/lib/docker:ro \
	-p 8080:8080 \
	--detach=true \
	--name=cadvisor \
	--net=host google/cadvisor

# 在监控主节点上部署prometheus server，客户节点无需安装
docker run -d -p 9090:9090 --name prometheus --net=host prom/prometheus
# 将容器中的配置文件拷贝到宿主，进行修改
docker cp prometheus:/etc/prometheus/prometheus.yml ./
# 修改static_configs，指向所有客户节点的9100和8080端口获取数据
vim prometheus.yml

# 配置更新完成后，删除原prometheus server容器
docker rm prometheus -f
# 重新将本地配置文件映射到容器中，访问9090端口进行验证
docker run -d -p 9090:9090 --name prometheus --net=host -v /root/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus

# 部署grafana图形化界面，访问3000端口进行验证
mkdir grafana-storage
chmod 777 -R grafana-storage/
docker run -d -p 3000:3000 \
	--name grafana \
	-v /root/grafana-storage:/var/lib/grafana \
	-e &quot;GF_SECURITY_ADMIN_PASSWORD=123456&quot; grafana/grafana
	
# grafana模板，打开grafana.com, 点击dashborads，根据数据源和类型选择合适的模板

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何拆除Linux软Raid设备]]></title>
        <id>https://esp0x.github.io/post/ru-he-chai-chu-linux-ruan-raid-she-bei/</id>
        <link href="https://esp0x.github.io/post/ru-he-chai-chu-linux-ruan-raid-she-bei/">
        </link>
        <updated>2021-04-20T08:11:37.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-shell">1. 卸载设备
# umount /dev/md0

2. 停止raid设备
# mdadm -S /dev/md0  // 停止raid设备

3. 查看属于raid组的设备名称
# blkid 

4. 从raid组中删除硬盘
# mdadm --misc --zero-superblock /dev/xxx

以下操作可选：
5. 删除配置文件：rm -f /etc/mdadm.conf

6. 更新/etc/fstab
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nmap工具常用使用场景]]></title>
        <id>https://esp0x.github.io/post/nmap-gong-ju-chang-yong-shi-yong-chang-jing/</id>
        <link href="https://esp0x.github.io/post/nmap-gong-ju-chang-yong-shi-yong-chang-jing/">
        </link>
        <updated>2021-03-29T05:50:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="主机发现">主机发现</h3>
<pre><code class="language-shell">以192.168.1.0/24举例

nmap -PE 192.168.1.0/24  # icmp
namp -PO 192.168.1.0/24  # ip
nmap -PS 192.168.1.0/24  # tcp syn
nmap -PA 192.168.1.0/24  # tcp ack
nmap -PU 192.168.1.0/24  # udp
nmap -PY 192.168.1.0/24  # sctp
</code></pre>
<h3 id="端口扫描">端口扫描</h3>
<pre><code class="language-shell">1.SYN Scanning
nmap -sS 192.168.1.0/24  # 仅发送SYN，返回SYN/ACK应答表示端口开启，返回RST表示端口关闭

2.TCP Scanning
nmap -sT 192.168.1.0/24  # 建立完整的TCP连接，表示端口开启，否则表示关闭

3.UDP Scanning
nmap -sU 192.168.1.0/24  # UDP，无应答，表示端口开启；返回&quot;Port Unreachable&quot;信息，表示关闭

4.FIN Scanning
nmap -sF 192.168.1.0/24  # 在TCP数据包中重置FIN标志位，无应答，表示开启；返回RST，表示端口关闭

5.NULL Scanning
nmap -sN 192.168.1.0/24  # 在TCP数据包中不包含任何标志位，无应答，表示开启；返回RST，表示端口关闭

6.Xmas Scanning
nmap -sX 192.168.1.0/24  # 在TCP数据包中重置FIN、RST、PUSH标志位，无应答，表示开启；返回RST，表示端口关闭

7.IDLE Scanning
nmap -sI 172.16.1.1 192.168.1.0/24  
# 利用僵尸主机进行扫描，假设僵尸IP为172.16.1.1，当僵尸机返回序列ID增加数量为2时，表示开启，为1时关闭

8.指定端口扫描
nmap -p 80,443 192.168.1.0/24  # 可以指定多个端口

9.扫描常见的100个端口
nmap -F 192.168.1.0/24  # 快速模式

10.使用协议名进行扫描
nmap -p http 192.168.1.0/24
nmap -p smtp 192.168.1.0/24

11.扫描常用端口
nmap --top-ports &lt;端口数量&gt; 192.168.1.0/24

</code></pre>
<h3 id="操作系统指纹识别">操作系统指纹识别</h3>
<pre><code class="language-shell">nmap -O 192.168.1.0/24   # os
nmap -sV 192.168.1.0/24  # service version
nmap -A 192.168.1.0/24   # all
</code></pre>
<h3 id="使用脚本">使用脚本</h3>
<pre><code class="language-shell">nmap --script &lt;脚本名称&gt; 192.168.1.0/24
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XFS文件系统修复流程]]></title>
        <id>https://esp0x.github.io/post/xfs-wen-jian-xi-tong-xiu-fu-liu-cheng/</id>
        <link href="https://esp0x.github.io/post/xfs-wen-jian-xi-tong-xiu-fu-liu-cheng/">
        </link>
        <updated>2021-03-22T02:34:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="详细流程如下">详细流程如下：</h3>
<p>1.使用 xfs_repair -n 执行文件系统错误检测，和 fsck -n 类似；<br>
2.使用 xfs_repair 尝试进行修复；<br>
3.当遇见无法正常挂载文件系统时，需要使用强制模式 -L 模式进行修复，会丢失部分数据，可以先对metadata进行模拟修复测试：</p>
<ul>
<li>xfs_metadump [partition] /path/to/file.metadump                                  # 对需要修复的分区进行dump</li>
<li>xfs_mdrestore /path/to/file.metadump /path/to/file.img                         # 生成img文件</li>
<li>losetup --show --find /path/to/file.img                                                    # 使用lostup工具将数据放到/dev/loop0</li>
<li>xfs_repair -L /dev/loop0                                                                        # 尝试模拟修复</li>
<li>mount /dev/loop0 /mnt</li>
<li>check the damage</li>
<li>(note, this is an image of file system layout, but not the actual data)</li>
</ul>
<p>4.拷贝真实数据，并对拷贝的数据进行修复：</p>
<ul>
<li>ddrescue -f -n [partition] /path/to/rescued.img rescue.log                      # 这需要一个比原分区大小更大的磁盘</li>
<li>ddrescue -d -f -r3 [partition] /path/to/rescued.img rescue.log</li>
<li>losetup --show --find /path/to/rescued.img</li>
<li>xfs_repair -L /dev/loop0</li>
<li>mount /dev/loop0 /mnt</li>
<li>check the damage</li>
</ul>
<p>5.如果真实环境缺少这样的备份分区，那么直接使用xfs_repair -L模式进行强制修复。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ipmitool工具的使用说明]]></title>
        <id>https://esp0x.github.io/post/ipmitool-gong-ju-de-shi-yong-shuo-ming/</id>
        <link href="https://esp0x.github.io/post/ipmitool-gong-ju-de-shi-yong-shuo-ming/">
        </link>
        <updated>2021-03-10T02:09:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="安装工具">安装工具</h3>
<pre><code class="language-shell">yum install -y ipmitool 
</code></pre>
<h3 id="启动服务">启动服务</h3>
<pre><code class="language-shell">service ipmi start
ipmitool -I open shell     # 进入交互式shell
</code></pre>
<h3 id="一-开关机重启">一、开关机，重启</h3>
<pre><code class="language-shell">1. 查看开关机状态：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) power status

2. 开机：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) power on

3. 关机：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) power off

4. 重启：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) power reset
</code></pre>
<h3 id="二-用户管理">二、用户管理</h3>
<pre><code class="language-shell"># 说明：[ChannelNo] 字段是可选的，ChannoNo为1或者8；BMC默认有2个用户：user id为1的匿名用户，user id为2的ADMIN用户；&lt;&gt;字段为必选内容；&lt;privilege level&gt;：2为user权限，3为Operator权限，4为Administrator权限；

1. 查看用户信息：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) user list [ChannelNo]

2. 增加用户：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) user set name &lt;user id&gt; &lt;username&gt;

3. 设置密码：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) user set password &lt;user id&gt; &lt;password&gt;

4. 设置用户权限：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) user priv &lt;user id&gt; &lt;privilege level&gt; [ChannelNo]

5. 启用/禁用用户：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) user enable/disable &lt;user id&gt;
</code></pre>
<h3 id="三-ip网络设置">三、IP网络设置</h3>
<pre><code class="language-shell"># 说明：[ChannelNo] 字段是可选的，ChannoNo为1(Share Nic网络)或者8（BMC独立管理网络）；设置网络参数，必须首先设置IP为静态，然后再进行其他设置；

1. 查看网络信息：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) lan print [ChannelNo]

2. 修改IP为静态还是DHCP模式：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) lan set &lt;ChannelNo&gt; ipsrc &lt;static/dhcp&gt;

3. 修改IP地址：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) lan set &lt;ChannelNo&gt; ipaddr &lt;IPAddress&gt;

4. 修改子网掩码：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) lan set &lt;ChannelNo&gt; netmask &lt;NetMask&gt;

5. 修改默认网关：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) lan set &lt;ChannelNo&gt; defgw ipaddr &lt;默认网关&gt;
</code></pre>
<h3 id="四-sol功能">四、SOL功能</h3>
<pre><code class="language-shell"># 说明：&lt;9.6/19.2/38.4/57.6/115.2&gt;其中115.2代表115200，即*1000是表示的波特率;

1. 设置SOL串口波特率：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) sol set volatile-bit-rate &lt;9.6/19.2/38.4/57.6/115.2&gt;

2. 打开SOL功能：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) sol activate

3. 关闭SOL功能：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) sol deactivate
</code></pre>
<h3 id="五-sel日志查看">五、SEL日志查看</h3>
<pre><code class="language-shell">1. 查看SEL日志：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) sel list
</code></pre>
<h3 id="六-fru信息查看">六、FRU信息查看</h3>
<pre><code class="language-shell">1. 查看FRU信息：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) fru list
</code></pre>
<h3 id="七-sdrsensor信息查看">七、SDR，Sensor信息查看</h3>
<pre><code class="language-shell">1. 查看SDR Sensor信息：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) sdr

2. 查看Sensor信息：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) sensor list
</code></pre>
<h3 id="八-mc管理单元bmc状态和控制">八、mc(管理单元BMC)状态和控制</h3>
<pre><code class="language-shell">1. 重启动BMC：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) mc reset &lt;warm/cold&gt;
</code></pre>
<h3 id="九-设置bmc的iptables防火墙">九、设置BMC的iptables防火墙</h3>
<pre><code class="language-shell">1. 设置某一段IP可以访问BMC
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x01 0x01 ip1(0xa 0xa 0xa 0xa) ip2(0xb 0xb 0xb 0xb)
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x09

2. 设置某个IP可以访问BMC
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x00 0x01 ip1(0xa 0xa 0xa 0xa)
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x09

3. 取消设置
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x08

4．获取防火墙设置
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x77 0x01 0x00

5. 阻止/开启某个端口
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x02 0x00/0x01 0x00 (portno)0x22 0x00

6. 取消某个端口的设置（6是5的对应取消操作）
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x06 0x00/0x01 0x00 (portno)0x22 0x00
</code></pre>
<h3 id="参考文献">参考文献</h3>
<p>https://www.cnblogs.com/EricDing/p/8995263.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NVIDIA显卡常用命令]]></title>
        <id>https://esp0x.github.io/post/nvidia-xian-qia-chang-yong-ming-ling/</id>
        <link href="https://esp0x.github.io/post/nvidia-xian-qia-chang-yong-ming-ling/">
        </link>
        <updated>2021-02-18T01:37:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="gpu日志收集">GPU日志收集</h3>
<pre><code class="language-shell"># nvidia-bug-report.sh   // 执行后输出nvidia-bug-report.log.gz文件
</code></pre>
<h3 id="驱动问题常见解决方法">驱动问题常见解决方法</h3>
<ol>
<li>维持较新的驱动版本</li>
<li>禁用nouveau模块</li>
<li>打开GPU驱动常驻内存模式并配置开机自启动</li>
<li>GPU故障后，可尝试重启主机解决</li>
</ol>
<h3 id="禁用nouveau模块">禁用nouveau模块</h3>
<pre><code class="language-shell"># lsmod | grep -i nouveau   // 如果有输出，表示启动状态，否则为禁用状态

# CentOS 7
# 编辑或新建 blacklist-nouveau.conf 文件
[root@zj ~]# vim /usr/lib/modprobe.d/blacklist-nouveau.conf
blacklist nouveau
options nouveau modeset=0

# 执行如下命令并重启系统使内核生效
[root@zj ~]# dracut -f
[root@zj ~]# shutdown -ry 0


# ubuntu 
# vi /etc/modprobe.d/blacklist.conf 最后一行加入
blacklist nouveau
# update-initramfs -u
# reboot
</code></pre>
<h3 id="gpu驱动内存常驻模式">GPU驱动内存常驻模式</h3>
<pre><code class="language-shell"># nvidia-smi -pm 1
</code></pre>
<h3 id="gpu加载数量和err检查">GPU加载数量和ERR检查</h3>
<pre><code class="language-shell"># 以下两个命令显示的GPU卡数量需要保持一致，可用于判断是否有GPU离线
# lspci | grep -i nvidia 
# nvidia-smi

# 检查输出中是否包含ERR错误字样，可用于实现健康检查
</code></pre>
<h3 id="gpu常用性能指标获取">GPU常用性能指标获取</h3>
<pre><code class="language-shell"># nvidia-smi \
&gt;  --query-gpu=memory.total,memory.used,memory.free,utilization.memory,utilization.gpu,temperature.gpu,fan.speed \
&gt;  --format=csv,noheader,nounits

# nvidia-smi --help-query-gpu   // 查看可用的查询参数
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解OAuth 2.0的基本流程]]></title>
        <id>https://esp0x.github.io/post/li-jie-oauth-20-de-ji-ben-liu-cheng/</id>
        <link href="https://esp0x.github.io/post/li-jie-oauth-20-de-ji-ben-liu-cheng/">
        </link>
        <updated>2021-02-04T01:00:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="快递员场景">快递员场景</h3>
<p>需求：有没有一种办法，让快递员能够自由出入小区，又不用知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限？</p>
<h3 id="授权机制的设计">授权机制的设计</h3>
<p>第一步，门禁系统的密码输入器下面，增加一个按钮，叫做&quot;获取授权&quot;。快递员需要首先按这个按钮，去申请授权。</p>
<p>第二步，他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。</p>
<p>我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。</p>
<p>第三步，门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。</p>
<p>第四步，快递员向门禁系统输入令牌，进入小区。</p>
<p>有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。</p>
<h3 id="转换理解">转换理解</h3>
<p>所以，OAuth就是一种授权机制，数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（Token），用于替代密码，以供第三方使用。</p>
<h3 id="关于token">关于Token</h3>
<p>只需要记住三点：1、令牌的有效期是有限的，为了安全；2、令牌的权限范围一般很小；3、令牌可以被撤销；</p>
<h3 id="参考文献">参考文献</h3>
<p>http://www.ruanyifeng.com/blog/2019/04/oauth_design.html</p>
]]></content>
    </entry>
</feed>