<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://esp0x.github.io</id>
    <title>Grey</title>
    <updated>2021-06-07T09:23:14.871Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://esp0x.github.io"/>
    <link rel="self" href="https://esp0x.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://esp0x.github.io/images/avatar.png</logo>
    <icon>https://esp0x.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Grey</rights>
    <entry>
        <title type="html"><![CDATA[Playbook中用户的切换问题]]></title>
        <id>https://esp0x.github.io/post/playbook-zhong-yong-hu-de-qie-huan-wen-ti/</id>
        <link href="https://esp0x.github.io/post/playbook-zhong-yong-hu-de-qie-huan-wen-ti/">
        </link>
        <updated>2021-06-07T09:21:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="become配置示例">become配置示例：</h3>
<pre><code class="language-shell">- hosts: www.360.com
  remote_user: zabbix
  become: yes
  become_method: su
  tasks:
   - selinux:
        state: disabled
   - name: disable firewalld
     shell: systemctl stop firewalld &amp;&amp; systemctl disable firewalld
 
# become说明
become:        yes  # 是否允许身份切换
become_method: su   # 切换用户身份的方式，有sudo、su、pbrun等方式，默认为sudo
become_user: root   # 切换指定的用户，默认不写，就是root
</code></pre>
<h3 id="sudo配置解释">sudo配置解释</h3>
<pre><code class="language-shell">hosts                # 指定主机分组，可以取并集，交集等
remote_user          # 用于指定远程主机上的执行任务的用户，最佳实践是该用户具有sudo权限
user                 # 和remote_user相同
sudo                 # 如果设置为yes，执行该任务组的用户在执行任务的时候，获取root权限，也可以命令行使用-b参数
sudo_user            # 如果设置user为A，sudo为yes，sudo_user为B时，则A用户在执行任务时会获得B用户的权限，比较麻烦，不推荐
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Playbook利用tags执行部分task]]></title>
        <id>https://esp0x.github.io/post/playbook-li-yong-tags-zhi-xing-bu-fen-task/</id>
        <link href="https://esp0x.github.io/post/playbook-li-yong-tags-zhi-xing-bu-fen-task/">
        </link>
        <updated>2021-06-07T09:20:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基本使用方法示例配置">基本使用方法，示例配置：</h3>
<pre><code class="language-shell">tasks:
  - yum: name={{ item }} state=installed
    with_items:
       - httpd
    tags:
       - packages
  - name: copy httpd.conf
    template: src=templates/httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf
    tags:
       - configuration
  - name: copy index.html
    template: src=templates/index.html.j2 dest=/var/www/html/index.html
    tags:
       - configuration
  
 
# 执行部分任务
ansible-playbook example.yml --tags &quot;packages&quot;

# 指定不执行packages部分的任务
ansible-playbook example.yml --skip-tags &quot;configuration&quot;
</code></pre>
<h3 id="特殊的tags">特殊的tags</h3>
<pre><code class="language-shell"># always 标签，即使指定执行了某tag的任务，标记为always的任务也会被执行
tasks:
  - debug: msg=&quot;Always print this debug message&quot;
    tags:
      - always
  - yum: name={{ item }} state=installed
    with_items:
       - httpd
    tags:
       - packages
  - template: src=templates/httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf
    tags:
       - configuration

# 这里标记为always的任务也会被执行
ansible-playbook tags_always.yml --tags &quot;packages&quot;

# targged，untagged，all，使用这些标签时，不需要加双引号
tagged，即执行所有被打标签的任务
untagged，即执行所有未被打标签的任务
all，所有任务
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用prometheus监控主机docker容器运行状态]]></title>
        <id>https://esp0x.github.io/post/shi-yong-prometheus-jian-kong-zhu-ji-docker-rong-qi-yun-xing-zhuang-tai/</id>
        <link href="https://esp0x.github.io/post/shi-yong-prometheus-jian-kong-zhu-ji-docker-rong-qi-yun-xing-zhuang-tai/">
        </link>
        <updated>2021-06-07T08:27:03.000Z</updated>
        <content type="html"><![CDATA[<h3 id="部署方式容器化部署">部署方式：容器化部署</h3>
<h4 id="部署流程">部署流程：</h4>
<pre><code class="language-shell"># 运行node-exporter监控主机基本信息，访问9100端口进行验证
docker run -d --name node \
	-p 9100:9100 \
	-v /proc:/host/proc \
	-v /sys:/host/sys \
	-v /:/rootfs \
	--net=host prom/node-exporter \
	--path.procfs /host/proc \
	--path.sysfs /host/sys \
	--collector.filesystem.ignored-mount-points &quot;^/(sys|proc|dev|host|etc)($|/)&quot;

# 运行cAdvisor监控容器运行状态，访问8080端口进行验证
docker run -v /:/rootfs:ro \
	-v /var/run:/var/run/:rw \
	-v /sys:/sys:ro \
	-v /var/lib/docker:/var/lib/docker:ro \
	-p 8080:8080 \
	--detach=true \
	--name=cadvisor \
	--net=host google/cadvisor

# 在监控主节点上部署prometheus server，客户节点无需安装
docker run -d -p 9090:9090 --name prometheus --net=host prom/prometheus
# 将容器中的配置文件拷贝到宿主，进行修改
docker cp prometheus:/etc/prometheus/prometheus.yml ./
# 修改static_configs，指向所有客户节点的9100和8080端口获取数据
vim prometheus.yml

# 配置更新完成后，删除原prometheus server容器
docker rm prometheus -f
# 重新将本地配置文件映射到容器中，访问9090端口进行验证
docker run -d -p 9090:9090 --name prometheus --net=host -v /root/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus

# 部署grafana图形化界面，访问3000端口进行验证
mkdir grafana-storage
chmod 777 -R grafana-storage/
docker run -d -p 3000:3000 \
	--name grafana \
	-v /root/grafana-storage:/var/lib/grafana \
	-e &quot;GF_SECURITY_ADMIN_PASSWORD=123456&quot; grafana/grafana
	
# grafana模板，打开grafana.com, 点击dashborads，根据数据源和类型选择合适的模板

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何拆除Linux软Raid设备]]></title>
        <id>https://esp0x.github.io/post/ru-he-chai-chu-linux-ruan-raid-she-bei/</id>
        <link href="https://esp0x.github.io/post/ru-he-chai-chu-linux-ruan-raid-she-bei/">
        </link>
        <updated>2021-04-20T08:11:37.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-shell">1. 卸载设备
# umount /dev/md0

2. 停止raid设备
# mdadm -S /dev/md0  // 停止raid设备

3. 查看属于raid组的设备名称
# blkid 

4. 从raid组中删除硬盘
# mdadm --misc --zero-superblock /dev/xxx

以下操作可选：
5. 删除配置文件：rm -f /etc/mdadm.conf

6. 更新/etc/fstab
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nmap工具常用使用场景]]></title>
        <id>https://esp0x.github.io/post/nmap-gong-ju-chang-yong-shi-yong-chang-jing/</id>
        <link href="https://esp0x.github.io/post/nmap-gong-ju-chang-yong-shi-yong-chang-jing/">
        </link>
        <updated>2021-03-29T05:50:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="主机发现">主机发现</h3>
<pre><code class="language-shell">以192.168.1.0/24举例

nmap -PE 192.168.1.0/24  # icmp
namp -PO 192.168.1.0/24  # ip
nmap -PS 192.168.1.0/24  # tcp syn
nmap -PA 192.168.1.0/24  # tcp ack
nmap -PU 192.168.1.0/24  # udp
nmap -PY 192.168.1.0/24  # sctp
</code></pre>
<h3 id="端口扫描">端口扫描</h3>
<pre><code class="language-shell">1.SYN Scanning
nmap -sS 192.168.1.0/24  # 仅发送SYN，返回SYN/ACK应答表示端口开启，返回RST表示端口关闭

2.TCP Scanning
nmap -sT 192.168.1.0/24  # 建立完整的TCP连接，表示端口开启，否则表示关闭

3.UDP Scanning
nmap -sU 192.168.1.0/24  # UDP，无应答，表示端口开启；返回&quot;Port Unreachable&quot;信息，表示关闭

4.FIN Scanning
nmap -sF 192.168.1.0/24  # 在TCP数据包中重置FIN标志位，无应答，表示开启；返回RST，表示端口关闭

5.NULL Scanning
nmap -sN 192.168.1.0/24  # 在TCP数据包中不包含任何标志位，无应答，表示开启；返回RST，表示端口关闭

6.Xmas Scanning
nmap -sX 192.168.1.0/24  # 在TCP数据包中重置FIN、RST、PUSH标志位，无应答，表示开启；返回RST，表示端口关闭

7.IDLE Scanning
nmap -sI 172.16.1.1 192.168.1.0/24  
# 利用僵尸主机进行扫描，假设僵尸IP为172.16.1.1，当僵尸机返回序列ID增加数量为2时，表示开启，为1时关闭

8.指定端口扫描
nmap -p 80,443 192.168.1.0/24  # 可以指定多个端口

9.扫描常见的100个端口
nmap -F 192.168.1.0/24  # 快速模式

10.使用协议名进行扫描
nmap -p http 192.168.1.0/24
nmap -p smtp 192.168.1.0/24

11.扫描常用端口
nmap --top-ports &lt;端口数量&gt; 192.168.1.0/24

</code></pre>
<h3 id="操作系统指纹识别">操作系统指纹识别</h3>
<pre><code class="language-shell">nmap -O 192.168.1.0/24   # os
nmap -sV 192.168.1.0/24  # service version
nmap -A 192.168.1.0/24   # all
</code></pre>
<h3 id="使用脚本">使用脚本</h3>
<pre><code class="language-shell">nmap --script &lt;脚本名称&gt; 192.168.1.0/24
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XFS文件系统修复流程]]></title>
        <id>https://esp0x.github.io/post/xfs-wen-jian-xi-tong-xiu-fu-liu-cheng/</id>
        <link href="https://esp0x.github.io/post/xfs-wen-jian-xi-tong-xiu-fu-liu-cheng/">
        </link>
        <updated>2021-03-22T02:34:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="详细流程如下">详细流程如下：</h3>
<p>1.使用 xfs_repair -n 执行文件系统错误检测，和 fsck -n 类似；<br>
2.使用 xfs_repair 尝试进行修复；<br>
3.当遇见无法正常挂载文件系统时，需要使用强制模式 -L 模式进行修复，会丢失部分数据，可以先对metadata进行模拟修复测试：</p>
<ul>
<li>xfs_metadump [partition] /path/to/file.metadump                                  # 对需要修复的分区进行dump</li>
<li>xfs_mdrestore /path/to/file.metadump /path/to/file.img                         # 生成img文件</li>
<li>losetup --show --find /path/to/file.img                                                    # 使用lostup工具将数据放到/dev/loop0</li>
<li>xfs_repair -L /dev/loop0                                                                        # 尝试模拟修复</li>
<li>mount /dev/loop0 /mnt</li>
<li>check the damage</li>
<li>(note, this is an image of file system layout, but not the actual data)</li>
</ul>
<p>4.拷贝真实数据，并对拷贝的数据进行修复：</p>
<ul>
<li>ddrescue -f -n [partition] /path/to/rescued.img rescue.log                      # 这需要一个比原分区大小更大的磁盘</li>
<li>ddrescue -d -f -r3 [partition] /path/to/rescued.img rescue.log</li>
<li>losetup --show --find /path/to/rescued.img</li>
<li>xfs_repair -L /dev/loop0</li>
<li>mount /dev/loop0 /mnt</li>
<li>check the damage</li>
</ul>
<p>5.如果真实环境缺少这样的备份分区，那么直接使用xfs_repair -L模式进行强制修复。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ipmitool工具的使用说明]]></title>
        <id>https://esp0x.github.io/post/ipmitool-gong-ju-de-shi-yong-shuo-ming/</id>
        <link href="https://esp0x.github.io/post/ipmitool-gong-ju-de-shi-yong-shuo-ming/">
        </link>
        <updated>2021-03-10T02:09:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="安装工具">安装工具</h3>
<pre><code class="language-shell">yum install -y ipmitool 
</code></pre>
<h3 id="启动服务">启动服务</h3>
<pre><code class="language-shell">service ipmi start
ipmitool -I open shell     # 进入交互式shell
</code></pre>
<h3 id="一-开关机重启">一、开关机，重启</h3>
<pre><code class="language-shell">1. 查看开关机状态：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) power status

2. 开机：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) power on

3. 关机：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) power off

4. 重启：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) power reset
</code></pre>
<h3 id="二-用户管理">二、用户管理</h3>
<pre><code class="language-shell"># 说明：[ChannelNo] 字段是可选的，ChannoNo为1或者8；BMC默认有2个用户：user id为1的匿名用户，user id为2的ADMIN用户；&lt;&gt;字段为必选内容；&lt;privilege level&gt;：2为user权限，3为Operator权限，4为Administrator权限；

1. 查看用户信息：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) user list [ChannelNo]

2. 增加用户：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) user set name &lt;user id&gt; &lt;username&gt;

3. 设置密码：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) user set password &lt;user id&gt; &lt;password&gt;

4. 设置用户权限：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) user priv &lt;user id&gt; &lt;privilege level&gt; [ChannelNo]

5. 启用/禁用用户：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) user enable/disable &lt;user id&gt;
</code></pre>
<h3 id="三-ip网络设置">三、IP网络设置</h3>
<pre><code class="language-shell"># 说明：[ChannelNo] 字段是可选的，ChannoNo为1(Share Nic网络)或者8（BMC独立管理网络）；设置网络参数，必须首先设置IP为静态，然后再进行其他设置；

1. 查看网络信息：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) lan print [ChannelNo]

2. 修改IP为静态还是DHCP模式：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) lan set &lt;ChannelNo&gt; ipsrc &lt;static/dhcp&gt;

3. 修改IP地址：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) lan set &lt;ChannelNo&gt; ipaddr &lt;IPAddress&gt;

4. 修改子网掩码：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) lan set &lt;ChannelNo&gt; netmask &lt;NetMask&gt;

5. 修改默认网关：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) lan set &lt;ChannelNo&gt; defgw ipaddr &lt;默认网关&gt;
</code></pre>
<h3 id="四-sol功能">四、SOL功能</h3>
<pre><code class="language-shell"># 说明：&lt;9.6/19.2/38.4/57.6/115.2&gt;其中115.2代表115200，即*1000是表示的波特率;

1. 设置SOL串口波特率：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) sol set volatile-bit-rate &lt;9.6/19.2/38.4/57.6/115.2&gt;

2. 打开SOL功能：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) sol activate

3. 关闭SOL功能：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) sol deactivate
</code></pre>
<h3 id="五-sel日志查看">五、SEL日志查看</h3>
<pre><code class="language-shell">1. 查看SEL日志：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) sel list
</code></pre>
<h3 id="六-fru信息查看">六、FRU信息查看</h3>
<pre><code class="language-shell">1. 查看FRU信息：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) fru list
</code></pre>
<h3 id="七-sdrsensor信息查看">七、SDR，Sensor信息查看</h3>
<pre><code class="language-shell">1. 查看SDR Sensor信息：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) sdr

2. 查看Sensor信息：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) sensor list
</code></pre>
<h3 id="八-mc管理单元bmc状态和控制">八、mc(管理单元BMC)状态和控制</h3>
<pre><code class="language-shell">1. 重启动BMC：
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) mc reset &lt;warm/cold&gt;
</code></pre>
<h3 id="九-设置bmc的iptables防火墙">九、设置BMC的iptables防火墙</h3>
<pre><code class="language-shell">1. 设置某一段IP可以访问BMC
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x01 0x01 ip1(0xa 0xa 0xa 0xa) ip2(0xb 0xb 0xb 0xb)
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x09

2. 设置某个IP可以访问BMC
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x00 0x01 ip1(0xa 0xa 0xa 0xa)
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x09

3. 取消设置
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x08

4．获取防火墙设置
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x77 0x01 0x00

5. 阻止/开启某个端口
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x02 0x00/0x01 0x00 (portno)0x22 0x00

6. 取消某个端口的设置（6是5的对应取消操作）
ipmitool -H (BMC的管理IP地址) -I lanplus -U (BMC登录用户名) -P (BMC 登录用户名的密码) raw 0x32 0x76 0x06 0x00/0x01 0x00 (portno)0x22 0x00
</code></pre>
<h3 id="参考文献">参考文献</h3>
<p>https://www.cnblogs.com/EricDing/p/8995263.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NVIDIA显卡常用命令]]></title>
        <id>https://esp0x.github.io/post/nvidia-xian-qia-chang-yong-ming-ling/</id>
        <link href="https://esp0x.github.io/post/nvidia-xian-qia-chang-yong-ming-ling/">
        </link>
        <updated>2021-02-18T01:37:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="gpu日志收集">GPU日志收集</h3>
<pre><code class="language-shell"># nvidia-bug-report.sh   // 执行后输出nvidia-bug-report.log.gz文件
</code></pre>
<h3 id="驱动问题常见解决方法">驱动问题常见解决方法</h3>
<ol>
<li>维持较新的驱动版本</li>
<li>禁用nouveau模块</li>
<li>打开GPU驱动常驻内存模式并配置开机自启动</li>
<li>GPU故障后，可尝试重启主机解决</li>
</ol>
<h3 id="禁用nouveau模块">禁用nouveau模块</h3>
<pre><code class="language-shell"># lsmod | grep -i nouveau   // 如果有输出，表示启动状态，否则为禁用状态

# CentOS 7
# 编辑或新建 blacklist-nouveau.conf 文件
[root@zj ~]# vim /usr/lib/modprobe.d/blacklist-nouveau.conf
blacklist nouveau
options nouveau modeset=0

# 执行如下命令并重启系统使内核生效
[root@zj ~]# dracut -f
[root@zj ~]# shutdown -ry 0


# ubuntu 
# vi /etc/modprobe.d/blacklist.conf 最后一行加入
blacklist nouveau
# update-initramfs -u
# reboot
</code></pre>
<h3 id="gpu驱动内存常驻模式">GPU驱动内存常驻模式</h3>
<pre><code class="language-shell"># nvidia-smi -pm 1
</code></pre>
<h3 id="gpu加载数量和err检查">GPU加载数量和ERR检查</h3>
<pre><code class="language-shell"># 以下两个命令显示的GPU卡数量需要保持一致，可用于判断是否有GPU离线
# lspci | grep -i nvidia 
# nvidia-smi

# 检查输出中是否包含ERR错误字样，可用于实现健康检查
</code></pre>
<h3 id="gpu常用性能指标获取">GPU常用性能指标获取</h3>
<pre><code class="language-shell"># nvidia-smi \
&gt;  --query-gpu=memory.total,memory.used,memory.free,utilization.memory,utilization.gpu,temperature.gpu,fan.speed \
&gt;  --format=csv,noheader,nounits

# nvidia-smi --help-query-gpu   // 查看可用的查询参数
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解OAuth 2.0的基本流程]]></title>
        <id>https://esp0x.github.io/post/li-jie-oauth-20-de-ji-ben-liu-cheng/</id>
        <link href="https://esp0x.github.io/post/li-jie-oauth-20-de-ji-ben-liu-cheng/">
        </link>
        <updated>2021-02-04T01:00:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="快递员场景">快递员场景</h3>
<p>需求：有没有一种办法，让快递员能够自由出入小区，又不用知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限？</p>
<h3 id="授权机制的设计">授权机制的设计</h3>
<p>第一步，门禁系统的密码输入器下面，增加一个按钮，叫做&quot;获取授权&quot;。快递员需要首先按这个按钮，去申请授权。</p>
<p>第二步，他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。</p>
<p>我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。</p>
<p>第三步，门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。</p>
<p>第四步，快递员向门禁系统输入令牌，进入小区。</p>
<p>有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。</p>
<h3 id="转换理解">转换理解</h3>
<p>所以，OAuth就是一种授权机制，数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（Token），用于替代密码，以供第三方使用。</p>
<h3 id="关于token">关于Token</h3>
<p>只需要记住三点：1、令牌的有效期是有限的，为了安全；2、令牌的权限范围一般很小；3、令牌可以被撤销；</p>
<h3 id="参考文献">参考文献</h3>
<p>http://www.ruanyifeng.com/blog/2019/04/oauth_design.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx配置文件详解]]></title>
        <id>https://esp0x.github.io/post/nginx-pei-zhi-wen-jian-xiang-jie/</id>
        <link href="https://esp0x.github.io/post/nginx-pei-zhi-wen-jian-xiang-jie/">
        </link>
        <updated>2021-02-03T06:15:08.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-shell">######Nginx配置文件nginx.conf中文详解#####

#定义Nginx运行的用户和用户组
user www www;

#nginx进程数，建议设置为等于CPU总核心数。
worker_processes 8;
 
#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]
error_log /usr/local/nginx/logs/error.log info;

#进程pid文件
pid /usr/local/nginx/logs/nginx.pid;

#指定进程可以打开的最大描述符：数目
#工作模式与连接数上限
#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。
#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。
#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。
worker_rlimit_nofile 65535;

events
{
    use epoll;

    #单个进程最大连接数（最大连接数=连接数*进程数）
    worker_connections 65535;

    #keepalive超时时间。
    keepalive_timeout 60;

    #分页大小可以用命令getconf PAGESIZE 取得。
    #getconf PAGESIZE 设置为该值的整数倍
    client_header_buffer_size 4k;

    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。
    open_file_cache max=65535 inactive=60s;

    #语法:open_file_cache_valid time 
    #默认值 60 
    #使用字段:http, server, location 
    #这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.
    open_file_cache_valid 80s;

    #语法:open_file_cache_min_uses number 
    #默认值: 1 
    #使用字段:http, server, location  
    #这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.
    open_file_cache_min_uses 1;
    
    #语法:open_file_cache_errors on | off 
    #默认值: off 
    #使用字段:http, server, location 
    #这个指令指定是否在搜索一个文件是记录cache错误.
    open_file_cache_errors on;
}
 
#设定http服务器，利用它的反向代理功能提供负载均衡支持
http
{
    #文件扩展名与文件类型映射表
    include mime.types;

    #默认文件类型
    default_type application/octet-stream;

    #默认编码
    #charset utf-8;

    #服务器名字的hash表大小
    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.
    server_names_hash_bucket_size 128;

    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。
    client_header_buffer_size 32k;

    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。
    large_client_header_buffers 4 64k;

    #设定通过nginx上传文件的大小
    client_max_body_size 8m;

    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。
    sendfile on;

    #开启目录列表访问，合适下载服务器，默认关闭。
    autoindex on;

    #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用
    tcp_nopush on;
    tcp_nodelay on;

    #长连接超时时间，单位是秒
    keepalive_timeout 120;

    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。
    fastcgi_connect_timeout 300;
    fastcgi_send_timeout 300;
    fastcgi_read_timeout 300;
    fastcgi_buffer_size 64k;
    fastcgi_buffers 4 64k;
    fastcgi_busy_buffers_size 128k;
    fastcgi_temp_file_write_size 128k;

    #gzip模块设置
    gzip on;               #开启gzip压缩输出
    gzip_min_length 1k;    #最小压缩文件大小
    gzip_buffers 4 16k;    #压缩缓冲区
    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）
    gzip_comp_level 2;     #压缩等级
    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。
    gzip_vary on;

    #开启限制IP连接数的时候需要使用
    #limit_zone crawler $binary_remote_addr 10m;

    #负载均衡配置
    upstream piao.jd.com {
        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。
        server 192.168.80.121:80 weight=3;
        server 192.168.80.122:80 weight=2;
        server 192.168.80.123:80 weight=3;

        #nginx的upstream目前支持4种方式的分配
        #1、轮询（默认）
        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。
        #2、weight
        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
        #2、ip_hash
        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。
        #例如：
        #upstream bakend {
        #    ip_hash;
        #    server 192.168.0.14:88;
        #    server 192.168.0.15:80;
        #}
        #3、fair（第三方）
        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。
        #upstream backend {
        #    server server1;
        #    server server2;
        #    fair;
        #}
        #4、url_hash（第三方）
        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。
        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法
        #upstream backend {
        #    server squid1:3128;
        #    server squid2:3128;
        #    hash $request_uri;
        #    hash_method crc32;
        #}

        #tips:
        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{
        #    ip_hash;
        #    server 127.0.0.1:9090 down;
        #    server 127.0.0.1:8080 weight=2;
        #    server 127.0.0.1:6060;
        #    server 127.0.0.1:7070 backup;
        #}
        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;

        #每个设备的状态设置为:
        #1.down表示单前的server暂时不参与负载
        #2.weight为weight越大，负载的权重就越大。
        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误
        #4.fail_timeout:max_fails次失败后，暂停的时间。
        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。

        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。
        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug
        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录
        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡
    }
     
     
     
    #虚拟主机的配置
    server
    {
        #监听端口
        listen 80;

        #域名可以有多个，用空格隔开
        server_name www.jd.com jd.com;
        index index.html index.htm index.php;
        root /data/www/jd;

        #对******进行负载均衡
        location ~ .*.(php|php5)?$
        {
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            include fastcgi.conf;
        }
         
        #图片缓存时间设置
        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$
        {
            expires 10d;
        }
         
        #JS和CSS缓存时间设置
        location ~ .*.(js|css)?$
        {
            expires 1h;
        }
         
        #日志格式设定
        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；
        #$remote_user：用来记录客户端用户名称；
        #$time_local： 用来记录访问时间与时区；
        #$request： 用来记录请求的url与http协议；
        #$status： 用来记录请求状态；成功是200，
        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；
        #$http_referer：用来记录从那个页面链接访问过来的；
        #$http_user_agent：记录客户浏览器的相关信息；
        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。
        log_format access '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
        '$status $body_bytes_sent &quot;$http_referer&quot; '
        '&quot;$http_user_agent&quot; $http_x_forwarded_for';
         
        #定义本虚拟主机的访问日志
        access_log  /usr/local/nginx/logs/host.access.log  main;
        access_log  /usr/local/nginx/logs/host.access.404.log  log404;
         
        #对 &quot;/&quot; 启用反向代理
        location / {
            proxy_pass http://127.0.0.1:88;
            proxy_redirect off;
            proxy_set_header X-Real-IP $remote_addr;
             
            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
             
            #以下是一些反向代理的配置，可选。
            proxy_set_header Host $host;

            #允许客户端请求的最大单文件字节数
            client_max_body_size 10m;

            #缓冲区代理缓冲用户端请求的最大字节数，
            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。
            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误
            client_body_buffer_size 128k;

            #表示使nginx阻止HTTP应答代码为400或者更高的应答。
            proxy_intercept_errors on;

            #后端服务器连接的超时时间_发起握手等候响应超时时间
            #nginx跟后端服务器连接超时时间(代理连接超时)
            proxy_connect_timeout 90;

            #后端服务器数据回传时间(代理发送超时)
            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据
            proxy_send_timeout 90;

            #连接成功后，后端服务器响应时间(代理接收超时)
            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）
            proxy_read_timeout 90;

            #设置代理服务器（nginx）保存用户头信息的缓冲区大小
            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小
            proxy_buffer_size 4k;

            #proxy_buffers缓冲区，网页平均在32k以下的设置
            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k
            proxy_buffers 4 32k;

            #高负荷下缓冲大小（proxy_buffers*2）
            proxy_busy_buffers_size 64k;

            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长
            #设定缓存文件夹大小，大于这个值，将从upstream服务器传
            proxy_temp_file_write_size 64k;
        }
         
        #设定查看Nginx状态的地址
        location /NginxStatus {
            stub_status on;
            access_log on;
            auth_basic &quot;NginxStatus&quot;;
            auth_basic_user_file confpasswd;
            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。
        }
         
        #本地动静分离反向代理配置
        #所有jsp的页面均交由tomcat或resin处理
        location ~ .(jsp|jspx|do)?$ {
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_pass http://127.0.0.1:8080;
        }
         
        #所有静态文件由nginx直接读取不经过tomcat或resin
        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|
        pdf|xls|mp3|wma)$
        {
            expires 15d; 
        }
         
        location ~ .*.(js|css)?$
        {
            expires 1h;
        }
    }
}
######Nginx配置文件nginx.conf中文详解#####
</code></pre>
]]></content>
    </entry>
</feed>