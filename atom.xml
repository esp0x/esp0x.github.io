<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://esp0x.github.io</id>
    <title>Grey</title>
    <updated>2021-06-23T03:47:47.050Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://esp0x.github.io"/>
    <link rel="self" href="https://esp0x.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://esp0x.github.io/images/avatar.png</logo>
    <icon>https://esp0x.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Grey</rights>
    <entry>
        <title type="html"><![CDATA[如何避免在第一次SSH登陆时输入yes提示符]]></title>
        <id>https://esp0x.github.io/post/ru-he-bi-mian-zai-di-yi-ci-ssh-deng-lu-shi-shu-ru-yes-ti-shi-fu/</id>
        <link href="https://esp0x.github.io/post/ru-he-bi-mian-zai-di-yi-ci-ssh-deng-lu-shi-shu-ru-yes-ti-shi-fu/">
        </link>
        <updated>2021-06-23T03:46:19.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-shell">echo &quot;StrictHostKeyChecking no&quot; &gt;~/.ssh/config
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s-Pod简单介绍]]></title>
        <id>https://esp0x.github.io/post/k8s-pod-jian-dan-jie-shao/</id>
        <link href="https://esp0x.github.io/post/k8s-pod-jian-dan-jie-shao/">
        </link>
        <updated>2021-06-08T07:06:03.000Z</updated>
        <content type="html"><![CDATA[<h3 id="概念">概念</h3>
<h5 id="在kubernetes集群中pod是所有业务类型的基础也是k8s管理的最小单位级它是一个或多个容器的组合-这些容器共享存储-网络和命名空间以及如何运行的规范-在pod中所有容器都被同一安排和调度并运行在共享的上下文中-对于具体应用而言pod是它们的逻辑主机pod包含业务相关的多个应用容器">在Kubernetes集群中，Pod是所有业务类型的基础，也是K8S管理的最小单位级，它是一个或多个容器的组合。这些容器共享存储、网络和命名空间，以及如何运行的规范。在Pod中，所有容器都被同一安排和调度，并运行在共享的上下文中。对于具体应用而言，Pod是它们的逻辑主机，Pod包含业务相关的多个应用容器。</h5>
<h3 id="两个注意点">两个注意点</h3>
<pre><code class="language-python">1.网络:
  每一个Pod都会被指派一个唯一的Ip地址，在Pod中的每一个容器共享网络命名空间，包括Ip地址和网络端口。在同一个Pod中的容器可以同locahost进行互相通信。当Pod中的容器需要与Pod外的实体进行通信时，则需要通过端口等共享的网络资源。

2.存储:
  Pod能够被指定共享存储卷的集合，在Pod中所有的容器能够访问共享存储卷，允许这些容器共享数据。存储卷也允许在一个Pod持久化数据，以防止其中的容器需要被重启。
</code></pre>
<h3 id="pod的生命周期">Pod的生命周期</h3>
<pre><code class="language-shel">一共有4种状态：

1. Pending：APIserver已经创建该server，但pod中有一个或多个容器的镜像还未创建，可能在下载中；
2. Running：Pod中的所有容器都已创建，且至少有一个容器处于运行状态，正在启动或重启状态；
3. Failed：Pod内所有容器都已退出，其中至少有一个容器退出失败；
4. Unknown：由于某种原因无法获取Pod的状态比如网络问题；
</code></pre>
<h3 id="pod的重启策略">Pod的重启策略</h3>
<pre><code class="language-py">重启策略对同一个Pod中的所有容器起作用，容器的重启由Node上的kubelet执行，支持三种策略，在配置文件中通过restartPolicy字段设置：
1. Always：只要退出就会重启
2. OnFailure：只有在失败退出时，才会重启
3. Never：只要退出，就不再重启

注意，这里的重启是指在Pod的宿主Node上进行本地重启，而不是调度到其它Node上。
</code></pre>
<h3 id="健康检查">健康检查</h3>
<pre><code class="language-shell"># 两种探针类型：
一、LivenessProbe探针：  判断容器是否存活（running）
1.ExecAction，在容器内部执行一个命令，状态返回码为0，表示健康，示例：
apiVersion: v1
kind: Pod
metadata:
 name: liveness
spec:
  containers:
  - name: liveness
    image: liveness
    args: 
    - /bin/sh
    - -c
    - echo ok &gt; /tmp/healthy: sleep 10; rm - rf /tmp/healthy; sleep 600
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/health
    initialDelaySeconds: 15
    timeoutSeconds: 1
    
2.TcpAction，通过IP和PORT，如果能够和容器建立连接则表示容器健康，示例：
apiVersion: v1
kind: Pod
metadata:
 name: pod-with-healthcheck
spec:
  containers:
  - name: nginx
    image: nginx
    ports:
    - containerPort: 80
    livenessProbe:
      tcpSocket:
        port: 80
    initialDelaySeconds: 15
    timeoutSeconds: 1
3.HttpGetAction，发送get请求，返回码在200-400之间表示健康， 示例：
apiVersion: v1
kind: Pod
metadata:
 name: pod-with-healthcheck
spec:
  containers:
  - name: nginx
    image: nginx
    ports:
    - containerPort: 80
    livenessProbe:
      httpGet:
        path: /_status/healthz  //请求路径
        port: 80
    initialDelaySeconds: 15
    timeoutSeconds: 1
    
二、ReadinessProbe探针： 用于判断容器是否启动完成（ready）
</code></pre>
<h3 id="pod的调度">Pod的调度</h3>
<pre><code class="language-shell"># 定向调度，nodeSelector
1.首先通过kubectl给node打上标签：
格式： kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;=&lt;label-value&gt;
kubectl label nodes node1 zone=north

2.在pod定义里选择某个node
apiVersion: v1
kind: Pod
metadata:
name: pod-with-healthcheck
spec:
containers:
- name: nginx
  image: nginx
  ports:
  - containerPort: 80
nodeSelector:
  zone: north

# 亲和性和非亲和性
一、Node affinity（节点亲和性）
1. requiredDuringSchedulingIgnoredDuringExecution：
可认为一种强制限制，如果 Node 的标签发生了变化导致其没有符合 Pod 的调度要求节点，那么pod调度就会失败。
2.preferredDuringSchedulingIgnoredDuringExecution：
软限或偏好，同样如果 Node 的标签发生了变化导致其不再符合 pod 的调度要求，pod 依然会调度运行。

二、Pod Affinity（Pod亲和性）
    podAffinity用于调度pod可以和哪些pod部署在同一拓扑结构之下。而podAntiAffinity相反，其用于规定pod不可以和哪些pod部署在同一拓扑结构下。通过pod affinity与anti-affinity来解决pod和pod之间的关系。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s-Namespace基本知识]]></title>
        <id>https://esp0x.github.io/post/namespace-ji-ben-zhi-shi/</id>
        <link href="https://esp0x.github.io/post/namespace-ji-ben-zhi-shi/">
        </link>
        <updated>2021-06-08T07:03:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="名词解释">名词解释</h3>
<h5 id="namespace是对一组资源和对象的抽象集合比如可用来将系统内部的对象划分为不同的项目或用户组-常见的podsservicesrc和deployments等都是属于某一个namespace的默认是default而nodepersistentvolumns等则不属于任何namespace">Namespace是对一组资源和对象的抽象集合，比如可用来将系统内部的对象划分为不同的项目或用户组。常见的pods，services，rc和deployments等都是属于某一个namespace的（默认是default），而node，persistentVolumns等则不属于任何namespace。</h5>
<h3 id="namespace相关操作">Namespace相关操作</h3>
<pre><code class="language-shell">kubectl可以通过–namespace或者-n选项指定namespace。如果不指定，默认为default。查看操作下,也可以通过设置–all-namespace=true来查看所有namespace下的资源。

# 查询ns
$ kubectl get namespaces
NAME          STATUS    AGE
default       Active    11d
kube-system   Active    11d

# 查询哪些资源位于namespace中
kubectl api-resources --namespaced=true
# 查看哪些资源不在命令空间
kubectl api-resources --namespaced=false

# 指定ns查询对应ns中的资源情况
kubectl get pods -n kube-system

# 创建
# 1.命令行直接创建
$ kubectl create namespace new-namespace

# 2.通过文件创建
$ cat my-namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: new-namespace

$ kubectl create -f ./my-namespace.yaml

# 删除，即删除该ns下所有资源
# 注意：default和kube-system命名空间不能删除
$ kubectl delete namespaces new-namespace

# 切换ns
kubectl config set-context --current --namespace=kube-system
</code></pre>
<h3 id="关于namespace是否隔离网络">关于Namespace是否隔离网络</h3>
<h5 id="一般情况下默认是不会隔离网络流量的除非对某个namespace设置了安全策略">一般情况下，默认是不会隔离网络流量的，除非对某个namespace设置了安全策略。</h5>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s-使用Minikube搭建本地学习环境]]></title>
        <id>https://esp0x.github.io/post/shi-yong-minikube-da-jian-ben-di-xue-xi-huan-jing/</id>
        <link href="https://esp0x.github.io/post/shi-yong-minikube-da-jian-ben-di-xue-xi-huan-jing/">
        </link>
        <updated>2021-06-08T07:02:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="安装kubectl">安装kubectl</h3>
<pre><code class="language-shell"># 注意：安装方法推荐参考官方网站，安装方式随着版本变更会发生变动
# 下载二进制文件
curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&quot;
# 下载校验文件
curl -LO &quot;https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256&quot;
# 检查下载文件和校验文件是否匹配
echo &quot;$(&lt;kubectl.sha256) kubectl&quot; | sha256sum --check
# 安装二进制文件
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
# 检查安装是否成功
kubectl version --client
</code></pre>
<h3 id="安装minikube">安装Minikube</h3>
<pre><code class="language-shell"># 下载二进制文件
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
# 安装二进制文件
sudo install minikube-linux-amd64 /usr/local/bin/minikube
# 启动集群，启动之前需要确保系统中有容器运行时，比如docker，kvm，否则集群启动失败
minikube start

# 若出现：The &quot;docker&quot; driver should not be used with root privileges.
# 将当前具有sudo权限的用户添加到docker组即可
sudo usermod -aG docker &lt;username&gt;
# 激活组的配置，这步必须
newgrp docker
# 再次启动
minikube start
# 查看集群信息
kubectl cluster-info

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ansible-Playbook中使用copy来传输文件]]></title>
        <id>https://esp0x.github.io/post/playbook-zhong-shi-yong-copy-lai-chuan-shu-wen-jian/</id>
        <link href="https://esp0x.github.io/post/playbook-zhong-shi-yong-copy-lai-chuan-shu-wen-jian/">
        </link>
        <updated>2021-06-07T09:27:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基本配置示例">基本配置示例</h3>
<pre><code class="language-shell">- hosts: all
    vars: 
      wss_url: http://10.77.10.125:8545 
    tasks:
      - name: &quot;推送配置文件&quot;
        template: src=/home/fm/ops/scripts/default.yaml dest=/etc/bee/default.yaml
      - name: &quot;send all scripts&quot;
        copy:
          src: '{{ item.src }}'
          dest: /tmp/
          owner: root
          group: root
          mode: 755
        with_items:
          - { src: '/home/fm/ops/scripts/start05.sh' }
          - { src: '/home/fm/ops/scripts/stop.sh' }
  
 
# 使用{{ item.src }}读取with_items中的数组元素，访问需要拷贝的每一个文件即可。

# 检查语法
ansible-playbook --syntax-check example.yaml
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ansible-Playbook中用户的切换问题]]></title>
        <id>https://esp0x.github.io/post/playbook-zhong-yong-hu-de-qie-huan-wen-ti/</id>
        <link href="https://esp0x.github.io/post/playbook-zhong-yong-hu-de-qie-huan-wen-ti/">
        </link>
        <updated>2021-06-07T09:21:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="become配置示例">become配置示例：</h3>
<pre><code class="language-shell">- hosts: www.360.com
  remote_user: zabbix
  become: yes
  become_method: su
  tasks:
   - selinux:
        state: disabled
   - name: disable firewalld
     shell: systemctl stop firewalld &amp;&amp; systemctl disable firewalld
 
# become说明
become:        yes  # 是否允许身份切换
become_method: su   # 切换用户身份的方式，有sudo、su、pbrun等方式，默认为sudo
become_user: root   # 切换指定的用户，默认不写，就是root
</code></pre>
<h3 id="sudo配置解释">sudo配置解释</h3>
<pre><code class="language-shell">hosts                # 指定主机分组，可以取并集，交集等
remote_user          # 用于指定远程主机上的执行任务的用户，最佳实践是该用户具有sudo权限
user                 # 和remote_user相同
sudo                 # 如果设置为yes，执行该任务组的用户在执行任务的时候，获取root权限，也可以命令行使用-b参数
sudo_user            # 如果设置user为A，sudo为yes，sudo_user为B时，则A用户在执行任务时会获得B用户的权限，比较麻烦，不推荐
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ansible-Playbook利用tags执行部分task]]></title>
        <id>https://esp0x.github.io/post/playbook-li-yong-tags-zhi-xing-bu-fen-task/</id>
        <link href="https://esp0x.github.io/post/playbook-li-yong-tags-zhi-xing-bu-fen-task/">
        </link>
        <updated>2021-06-07T09:20:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基本使用方法示例配置">基本使用方法，示例配置：</h3>
<pre><code class="language-shell">tasks:
  - yum: name={{ item }} state=installed
    with_items:
       - httpd
    tags:
       - packages
  - name: copy httpd.conf
    template: src=templates/httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf
    tags:
       - configuration
  - name: copy index.html
    template: src=templates/index.html.j2 dest=/var/www/html/index.html
    tags:
       - configuration
  
 
# 执行部分任务
ansible-playbook example.yml --tags &quot;packages&quot;

# 指定不执行packages部分的任务
ansible-playbook example.yml --skip-tags &quot;configuration&quot;
</code></pre>
<h3 id="特殊的tags">特殊的tags</h3>
<pre><code class="language-shell"># always 标签，即使指定执行了某tag的任务，标记为always的任务也会被执行
tasks:
  - debug: msg=&quot;Always print this debug message&quot;
    tags:
      - always
  - yum: name={{ item }} state=installed
    with_items:
       - httpd
    tags:
       - packages
  - template: src=templates/httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf
    tags:
       - configuration

# 这里标记为always的任务也会被执行
ansible-playbook tags_always.yml --tags &quot;packages&quot;

# targged，untagged，all，使用这些标签时，不需要加双引号
tagged，即执行所有被打标签的任务
untagged，即执行所有未被打标签的任务
all，所有任务
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prometheus-使用prometheus监控主机docker容器运行状态]]></title>
        <id>https://esp0x.github.io/post/shi-yong-prometheus-jian-kong-zhu-ji-docker-rong-qi-yun-xing-zhuang-tai/</id>
        <link href="https://esp0x.github.io/post/shi-yong-prometheus-jian-kong-zhu-ji-docker-rong-qi-yun-xing-zhuang-tai/">
        </link>
        <updated>2021-06-07T08:27:03.000Z</updated>
        <content type="html"><![CDATA[<h3 id="部署方式容器化部署">部署方式：容器化部署</h3>
<h4 id="部署流程">部署流程：</h4>
<pre><code class="language-shell"># 运行node-exporter监控主机基本信息，访问9100端口进行验证
docker run -d --name node \
	-p 9100:9100 \
	-v /proc:/host/proc \
	-v /sys:/host/sys \
	-v /:/rootfs \
	--net=host prom/node-exporter \
	--path.procfs /host/proc \
	--path.sysfs /host/sys \
	--collector.filesystem.ignored-mount-points &quot;^/(sys|proc|dev|host|etc)($|/)&quot;

# 运行cAdvisor监控容器运行状态，访问8080端口进行验证
docker run -v /:/rootfs:ro \
	-v /var/run:/var/run/:rw \
	-v /sys:/sys:ro \
	-v /var/lib/docker:/var/lib/docker:ro \
	-p 8080:8080 \
	--detach=true \
	--name=cadvisor \
	--net=host google/cadvisor

# 在监控主节点上部署prometheus server，客户节点无需安装
docker run -d -p 9090:9090 --name prometheus --net=host prom/prometheus
# 将容器中的配置文件拷贝到宿主，进行修改
docker cp prometheus:/etc/prometheus/prometheus.yml ./
# 修改static_configs，指向所有客户节点的9100和8080端口获取数据
vim prometheus.yml

# 配置更新完成后，删除原prometheus server容器
docker rm prometheus -f
# 重新将本地配置文件映射到容器中，访问9090端口进行验证
docker run -d -p 9090:9090 --name prometheus --net=host -v /root/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus

# 部署grafana图形化界面，访问3000端口进行验证
mkdir grafana-storage
chmod 777 -R grafana-storage/
docker run -d -p 3000:3000 \
	--name grafana \
	-v /root/grafana-storage:/var/lib/grafana \
	-e &quot;GF_SECURITY_ADMIN_PASSWORD=123456&quot; grafana/grafana
	
# grafana模板，打开grafana.com, 点击dashborads，根据数据源和类型选择合适的模板

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何拆除Linux软Raid设备]]></title>
        <id>https://esp0x.github.io/post/ru-he-chai-chu-linux-ruan-raid-she-bei/</id>
        <link href="https://esp0x.github.io/post/ru-he-chai-chu-linux-ruan-raid-she-bei/">
        </link>
        <updated>2021-04-20T08:11:37.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-shell">1. 卸载设备
# umount /dev/md0

2. 停止raid设备
# mdadm -S /dev/md0  // 停止raid设备

3. 查看属于raid组的设备名称
# blkid 

4. 从raid组中删除硬盘
# mdadm --misc --zero-superblock /dev/xxx

以下操作可选：
5. 删除配置文件：rm -f /etc/mdadm.conf

6. 更新/etc/fstab
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nmap工具常用使用场景]]></title>
        <id>https://esp0x.github.io/post/nmap-gong-ju-chang-yong-shi-yong-chang-jing/</id>
        <link href="https://esp0x.github.io/post/nmap-gong-ju-chang-yong-shi-yong-chang-jing/">
        </link>
        <updated>2021-03-29T05:50:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="主机发现">主机发现</h3>
<pre><code class="language-shell">以192.168.1.0/24举例

nmap -PE 192.168.1.0/24  # icmp
namp -PO 192.168.1.0/24  # ip
nmap -PS 192.168.1.0/24  # tcp syn
nmap -PA 192.168.1.0/24  # tcp ack
nmap -PU 192.168.1.0/24  # udp
nmap -PY 192.168.1.0/24  # sctp
</code></pre>
<h3 id="端口扫描">端口扫描</h3>
<pre><code class="language-shell">1.SYN Scanning
nmap -sS 192.168.1.0/24  # 仅发送SYN，返回SYN/ACK应答表示端口开启，返回RST表示端口关闭

2.TCP Scanning
nmap -sT 192.168.1.0/24  # 建立完整的TCP连接，表示端口开启，否则表示关闭

3.UDP Scanning
nmap -sU 192.168.1.0/24  # UDP，无应答，表示端口开启；返回&quot;Port Unreachable&quot;信息，表示关闭

4.FIN Scanning
nmap -sF 192.168.1.0/24  # 在TCP数据包中重置FIN标志位，无应答，表示开启；返回RST，表示端口关闭

5.NULL Scanning
nmap -sN 192.168.1.0/24  # 在TCP数据包中不包含任何标志位，无应答，表示开启；返回RST，表示端口关闭

6.Xmas Scanning
nmap -sX 192.168.1.0/24  # 在TCP数据包中重置FIN、RST、PUSH标志位，无应答，表示开启；返回RST，表示端口关闭

7.IDLE Scanning
nmap -sI 172.16.1.1 192.168.1.0/24  
# 利用僵尸主机进行扫描，假设僵尸IP为172.16.1.1，当僵尸机返回序列ID增加数量为2时，表示开启，为1时关闭

8.指定端口扫描
nmap -p 80,443 192.168.1.0/24  # 可以指定多个端口

9.扫描常见的100个端口
nmap -F 192.168.1.0/24  # 快速模式

10.使用协议名进行扫描
nmap -p http 192.168.1.0/24
nmap -p smtp 192.168.1.0/24

11.扫描常用端口
nmap --top-ports &lt;端口数量&gt; 192.168.1.0/24

</code></pre>
<h3 id="操作系统指纹识别">操作系统指纹识别</h3>
<pre><code class="language-shell">nmap -O 192.168.1.0/24   # os
nmap -sV 192.168.1.0/24  # service version
nmap -A 192.168.1.0/24   # all
</code></pre>
<h3 id="使用脚本">使用脚本</h3>
<pre><code class="language-shell">nmap --script &lt;脚本名称&gt; 192.168.1.0/24
</code></pre>
]]></content>
    </entry>
</feed>